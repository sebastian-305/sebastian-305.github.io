<html>

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Damenproblem</title>
    <link rel="icon" type="image/x-icon" href="./icons/crown.ico">
    <style type="text/css">
        #beschriftung {
            border: 0px;
            outline: none;
        }

        div {
            outline: 1px solid black;
        }

        .field {
            display: table-cell;
            width: 50px;
            height: 50px;
            text-align: center;
            vertical-align: middle;
            font-size: 18pt;
            background-color: #EFEFEF
        }

        .queen {
            background-color: brown;
            color: white;
        }

        #wrapper {
            display: table;
            table-layout: fixed;
            /*width: 400px;
            height: 400px;*/
            outline: 2px solid black;
        }

        button {}

        .button {
            display: inline-block;
            height: 30px;
            width: 30px;
            font-size: 15pt;
            text-align: center;
            vertical-align: middle;
            background-color: EFEFEF;
            border-radius: 10px;
        }

        .button:hover {
            color: white;
            background-color: grey;
            cursor: pointer;
        }

        .unselectable {
            -moz-user-select: -moz-none;
            -khtml-user-select: none;
            -webkit-user-select: none;

            /*
     Introduced in IE 10.
     See http://ie.microsoft.com/testdrive/HTML5/msUserSelect/
   */
            -ms-user-select: none;
            user-select: none;
        }
    </style>
    <script>
        /* Nice stack overflow code to compare Arrays*/
        //Source: https://stackoverflow.com/questions/7837456/how-to-compare-arrays-in-javascript#14853974

        // Warn if overriding existing method
        if (Array.prototype.equals)
            console.warn("Overriding existing Array.prototype.equals. Possible causes: New API defines the method, there's a framework conflict or you've got double inclusions in your code.");
        // attach the .equals method to Array's prototype to call it on any array
        Array.prototype.equals = function (array) {
            // if the other array is a falsy value, return
            if (!array)
                return false;

            // compare lengths - can save a lot of time 
            if (this.length != array.length)
                return false;

            for (var i = 0, l = this.length; i < l; i++) {
                // Check if we have nested arrays
                if (this[i] instanceof Array && array[i] instanceof Array) {
                    // recurse into the nested arrays
                    if (!this[i].equals(array[i]))
                        return false;
                }
                else if (this[i] != array[i]) {
                    // Warning - two different object instances will never be equal: {x:20} != {x:20}
                    return false;
                }
            }
            return true;
        }
        // Hide method from for-in loops
        Object.defineProperty(Array.prototype, "equals", { enumerable: false });
            /* End of stack overflow code*/
    </script>
</head>

<body>
    <div id="beschriftung">
        <br>
        <h1>Das Damenproblem</h1>
        <br>
        <label for="Spielfeld">Seitenlänge des Spielfeldes</label>
        <select name="Spielfeld" id="BoardSizeSelect">
            <option value="1">1</option>
            <option value="4">4</option>
            <option value="5">5</option>
            <option value="6">6</option>
            <option value="7">7</option>
            <option selected value="8">8</option>
            <option value="9">9</option>
            <option value="10">10</option>
            <option value="11">11</option>
        </select>
        <label>Berechnungsart:</label>
        <select name="Berechnungsart" id="CalcMethodSelect">
            <option value="rek">rekursive Funktion</option>
            <option value="loop">Schleifenfunktion</option>
        </select>
        <button onclick="updateAll()">berechnen</button>
        <br>
        <label for="Damen">Lösung auswählen:</label>
        <select name="Damen" id="DamenSelect" onchange="updateFieldWithOtherSolution();">
            <option>0,12,23,29,34,46,49,59</option>
        </select>
        <div class="button unselectable" name="rotieren" title="Spielfeld rotieren"
            onclick="updateFieldWithOtherSolution('rotate')">
            <span> &#11118;</span>
        </div>
        <div class="button unselectable" name="horizontal spiegeln" title="Spielfeld horizontal spiegeln"
            onclick="updateFieldWithOtherSolution('flipH')"><span> &#8646; </span></div>
        <div class="button unselectable" name="vertikal spiegeln" title="Spielfeld vertikal spiegeln"
            onclick="updateFieldWithOtherSolution('flipV')"><span> &#8645; </span></div>
        <br>
        <label for="uniqueSoltions">Eindeutige Lösungen: </label> <span id="uniqueSoltions">0</span>
        <br>
        <label for="totalSolutions">Lösungen insgesamt: </label> <span id="totalSolutions">0</span>
        <p>Ladezeit: <span id="loadTime">0 ms</span></p>
    </div>
    <br>
    <br>
    <img id="loadingGif" src="images/Loadingsome.gif" alt="Loading" width="300" height="300">
    <div id="wrapper">
    </div>
    <!-- JAVASCRIPT CODE HIER! -->
    <script>
        let queenProblemProperties = {
            'startTime': 0,
            'fieldSize': 8,
            'calcuationMethod': 'rek',
            'iterator': 0,
            'solutionsFound': 0,
            'totalSolutionsFound': 0,
            'allSolutionsArray': [],
            'flipHorizontal': false,
            'flipVertical': false,
            'rotation': 1,
            'currentDisplayedSolution': []
        };

        let loadingGif = document.querySelector("#loadingGif");
        queenProblemProperties.startTime = new Date().getTime();

        calculateSolutionsRecursive(queenProblemProperties.allSolutionsArray); //Lösungen berechnen

        drawSolutionAsHtml(queenProblemProperties.currentDisplayedSolution = queenProblemProperties.allSolutionsArray[0]); //Feld zeichnen mit erster Lösung

        fillDropDownWithSolutions(queenProblemProperties.allSolutionsArray); //Drop Down Menü befüllen

        //console.log(`Iterationen der Hauptfunktion: ${queenProblemProperties.iterator}`); //Nicht so wichtig


        /************************************************************************************************/
        /* FUNKTIONEN */

        function fillDropDownWithSolutions(allSolutionsArray) //Drop Down Menü befüllen
        {
            let dropDownMenu = document.getElementById('DamenSelect');
            let menuItemStringAsHtmlCode;

            dropDownMenu.innerHTML = "";

            for (let elements of allSolutionsArray) {
                menuItemStringAsHtmlCode = "<option >"
                menuItemStringAsHtmlCode += elements
                menuItemStringAsHtmlCode += "</option>"
                dropDownMenu.innerHTML += menuItemStringAsHtmlCode;
            }

            let loadTime = new Date().getTime() - queenProblemProperties.startTime;
            document.getElementById("loadTime").innerHTML = `${Math.floor(loadTime / 1000)} s ${loadTime % 1000} ms`;
        }

        function updateFieldWithOtherSolution(state = 'reset') //Funktion wird beim Ändern des Drop Down Menüs aufgerufen
        {
            switch (state) {
                case 'reset':
                    let dropDownMenu = document.getElementById('DamenSelect');
                    let selectedIndexOfDropDownMenu = dropDownMenu.selectedIndex;
                    queenProblemProperties.currentDisplayedSolution = [...queenProblemProperties.allSolutionsArray[selectedIndexOfDropDownMenu]];
                    queenProblemProperties.flipVertical = false;
                    queenProblemProperties.flipHorizontal = false;
                    queenProblemProperties.rotation = 1;
                    break;
                case 'flipV':
                    queenProblemProperties.flipVertical = !queenProblemProperties.flipVertical;
                    queenProblemProperties.currentDisplayedSolution = [...flipVertical(queenProblemProperties.currentDisplayedSolution)];
                    break;
                case 'flipH':
                    queenProblemProperties.flipHorizontal = !queenProblemProperties.flipHorizontal;
                    queenProblemProperties.currentDisplayedSolution = [...flipHorizontal(queenProblemProperties.currentDisplayedSolution)];
                    break;
                case 'rotate':
                    queenProblemProperties.rotation = (queenProblemProperties.rotation === 1) ? 4 : queenProblemProperties.rotation - 1;
                    queenProblemProperties.currentDisplayedSolution = [...rotateLeft90degree(queenProblemProperties.currentDisplayedSolution, 3)];
                    break;
            }
            drawSolutionAsHtml(queenProblemProperties.currentDisplayedSolution);
        }

        function updateAll() {

            let currentBoard = document.querySelector("#wrapper").innerHTML;
            loadingGif.style.display = 'inline';
            document.querySelector("#wrapper").innerHTML = "";

            if (!confirm("This task may take several seconds. Do you wish to continue?")) {
                document.querySelector("#wrapper").innerHTML = currentBoard;
                loadingGif.style.display = 'none';
                return;
            }

            window.setTimeout(() => { console.log("Timeout over") }, 100);

            queenProblemProperties = {
                'startTime': 0,
                'fieldSize': 8,
                'calcuationMethod': 'rek',
                'iterator': 0,
                'solutionsFound': 0,
                'totalSolutionsFound': 0,
                'allSolutionsArray': [],
                'flipHorizontal': false,
                'flipVertical': false,
                'rotation': 1,
                'currentDisplayedSolution': []
            };

            queenProblemProperties.startTime = new Date().getTime();

            loadingGif.style.display = 'inline';
            document.querySelector("#wrapper").innerHTML = "";

            queenProblemProperties.fieldSize = Number(document.getElementById('BoardSizeSelect').value);
            queenProblemProperties.calcuationMethod = document.getElementById('CalcMethodSelect').value;
            // console.log(`Calc Method: ${queenProblemProperties.calcuationMethod}`);

            document.addEventListener('DOMContentLoaded', (event) => {
  //the event occurred


            if (queenProblemProperties.calcuationMethod === 'rek') {
                calculateSolutionsRecursive(queenProblemProperties.allSolutionsArray);
                console.log(`Iterationen der Hauptfunktion: ${queenProblemProperties.iterator}`); //Nicht so wichtig
            } else {
                calculateSolutionsInLoop(queenProblemProperties.allSolutionsArray);
            }

            console.table(queenProblemProperties.allSolutionsArray);
            fillDropDownWithSolutions(queenProblemProperties.allSolutionsArray); //Drop Down Menü befüllen 

            drawSolutionAsHtml(queenProblemProperties.currentDisplayedSolution = queenProblemProperties.allSolutionsArray[0]);
        })
        }

        function drawSolutionAsHtml(solution1d) //Spielfeld mit der jeweiligen Lösung in das HTML übertragen
        {
            let solution2d = convertSolutionFrom1dIn2dArrayWithFlags(solution1d)
            let counter = 0;
            let target = document.getElementById("wrapper");
            let rowStringAsHtmlCode; //Speichert HTML code, der dann in die Webseite geschrieben wird
            target.innerHTML = ""; //Wir setzen das Spielfeld zurück

            loadingGif.style.display = 'none';

            for (let y_index in solution2d) {
                rowStringAsHtmlCode = "<div>"; //Neue Zeile

                for (let x_index in solution2d[y_index]) //Alle Felder einer Reihe setzen
                {

                    if (solution2d[y_index][x_index]) //Wenn das Feld 'true' ist, steht eine Dame darauf und wir färben es mit der CSS Klasse queen
                    {
                        rowStringAsHtmlCode += "<div class='field queen unselectable'>"
                    }
                    else {
                        rowStringAsHtmlCode += "<div class='field unselectable'>"
                    }
                    rowStringAsHtmlCode += counter;
                    rowStringAsHtmlCode += "</div>";
                    counter++
                }

                rowStringAsHtmlCode += "</div>";
                target.innerHTML += rowStringAsHtmlCode; //Zeile Zeichnen
            }

            document.getElementById("uniqueSoltions").innerHTML = queenProblemProperties.solutionsFound;
            document.getElementById("totalSolutions").innerHTML = queenProblemProperties.totalSolutionsFound;


            function convertSolutionFrom1dIn2dArrayWithFlags(solution1d) //Die jeweilige Lösung als einen 2-dimensionalen Boolean Array berechnen
            {
                let solution2d = new Array(queenProblemProperties.fieldSize);

                for (let i = 0; i < queenProblemProperties.fieldSize; ++i) {
                    solution2d[i] = new Array(queenProblemProperties.fieldSize)
                    solution2d[i].fill(false); //Alle Werte standardmäßig auf "false" setzen, auch wird dadurch der Array als Boolean Array initialisiert
                }

                for (let queen of solution1d) {
                    solution2d[Math.floor(queen / queenProblemProperties.fieldSize)][queen % queenProblemProperties.fieldSize] = true; //Position der jeweiligen Dame in den 2-dimensionalen Array eintragen
                }

                return solution2d;
            }
        }

        function calculateSolutionsRecursive(saveSolutionsHere, arrayOfLegitQueens = [], startCheckingCurrentQueenFromHere = 0) //Rekursive Funtion um die Lösungen zu berechnen
        {
            queenProblemProperties.iterator++;

            if (arrayOfLegitQueens[arrayOfLegitQueens.length - 1] > arrayOfLegitQueens.length * queenProblemProperties.fieldSize) // Unnötige Iterationen verwerfen
            {
                return false;
            }

            for (let currentlyInvestigatedQueen = startCheckingCurrentQueenFromHere; currentlyInvestigatedQueen < (queenProblemProperties.fieldSize * queenProblemProperties.fieldSize); currentlyInvestigatedQueen++) //Wir probieren alle Felder aus, ob die Felder zu einer Lösung führen
            {
                if (checkCollisions(arrayOfLegitQueens, currentlyInvestigatedQueen)) //Wenn es eine Kollision gibt, können wir den Rest der Schleife überspringen
                {
                    continue;
                }

                arrayOfLegitQueens.push(currentlyInvestigatedQueen);

                if (arrayOfLegitQueens.length === queenProblemProperties.fieldSize) //Eine Lösung gefunden!
                {
                    queenProblemProperties.totalSolutionsFound++;

                    if (!checkIfSolutionExcists(saveSolutionsHere, arrayOfLegitQueens)) {
                        saveSolutionsHere.push([...arrayOfLegitQueens]); //Lösung speichern
                        queenProblemProperties.solutionsFound++;
                    }
                    arrayOfLegitQueens.pop();
                    continue; //Weitersuchen
                }

                if (calculateSolutionsRecursive(saveSolutionsHere, arrayOfLegitQueens, currentlyInvestigatedQueen + 1)) //die jetzige Position der Dame passt soweit, jetzt können wir eine weitere Dame hinzufügen
                {
                    return true;
                }
                arrayOfLegitQueens.pop();
            }
            return;
        }

        function calculateSolutionsInLoop(saveSolutionsHere) {

            let calculationArray = new Array(queenProblemProperties.fieldSize);
            calculationArray.fill(0);
            let pointer = 0;
            let finished = false;
            let currentSolution;

            do {
                pointer = 0;
                currentSolution = convertSoltionInConsecutiveNumbers([...calculationArray]);

                if (!checkCollisonRowForLoopfunction(calculationArray)) {
                    if (!checkCollisionQueenArray([...currentSolution])) {
                        queenProblemProperties.totalSolutionsFound++;
                        if (!checkIfSolutionExcists(saveSolutionsHere, currentSolution)) {
                            saveSolutionsHere.push([...currentSolution]); //Lösung speichern
                            queenProblemProperties.solutionsFound++;
                        }
                    }
                }

                while (++calculationArray[pointer] === queenProblemProperties.fieldSize) {
                    calculationArray[pointer] = 0;
                    ++pointer;

                    if (pointer === queenProblemProperties.fieldSize) {
                        finished = true;
                        break;
                    }
                }
            }
            while (!finished)




            function convertSoltionInConsecutiveNumbers(solution = []) {
                solution.forEach(function (cur, index, arr) { arr[index] = cur + index * arr.length });
                return solution;
            }
        }

        function checkCollisionQueenArray(queenArray) {
            collision = false;
            let tempArray;
            for (let index = 0; index < queenArray.length; ++index) {
                if (index === queenArray.length - 1) {
                    break;
                }
                tempArray = [...queenArray]
                tempArray.splice(0, index + 1);
                if (checkCollisions(tempArray, queenArray[index])) {
                    return true;
                }
            }
            return collision;
        }

        function checkCollisions(arrayOfLegitQueens, currentlyInvestigatedQueen) //Wir prüfen ob die jetztige Dame mit anderen Damen kolidiert
        {

            if (arrayOfLegitQueens.length === 0) //Wenn es keine weiteren Damen gibt, kann es keine Kollisionen geben 
            {
                return false;
            }

            for (let currentLegitQueen of arrayOfLegitQueens) //Alle bisher gefundenen Damen überprüfen, ob diese mit der jetzigen Dame kolidieren
            {
                if (Math.floor(currentLegitQueen / queenProblemProperties.fieldSize) === Math.floor(currentlyInvestigatedQueen / queenProblemProperties.fieldSize)) //Zeile testen
                {
                    return true;
                }

                if (currentLegitQueen % queenProblemProperties.fieldSize === currentlyInvestigatedQueen % queenProblemProperties.fieldSize) //Spalte testen
                {
                    return true;
                }

                if (checkDiagonalCollisions(currentLegitQueen, currentlyInvestigatedQueen)) //Diagonal ist komplizierter, darum wurde das auf eine eigene Funktion ausgelagert
                {
                    return true;
                }
            }
            return false;

            function checkDiagonalCollisions(currentLegitQueen, currentlyInvestigatedQueen) //Diagonal auf Kollisionen überprüfen
            {
                for (let currentFieldToCheck = currentlyInvestigatedQueen; currentFieldToCheck % queenProblemProperties.fieldSize <= currentlyInvestigatedQueen % queenProblemProperties.fieldSize && currentFieldToCheck >= currentLegitQueen; currentFieldToCheck -= (queenProblemProperties.fieldSize + 1)) //Nach links oben
                {
                    if (currentFieldToCheck === currentLegitQueen) {
                        return true;
                    }
                }

                for (let currentFieldToCheck = currentlyInvestigatedQueen; currentFieldToCheck % queenProblemProperties.fieldSize >= currentlyInvestigatedQueen % queenProblemProperties.fieldSize && currentFieldToCheck >= currentLegitQueen; currentFieldToCheck -= (queenProblemProperties.fieldSize - 1)) //Nach rechts oben
                {
                    if (currentFieldToCheck === currentLegitQueen) {
                        return true;
                    }
                }

                for (let currentFieldToCheck = currentlyInvestigatedQueen; currentFieldToCheck % queenProblemProperties.fieldSize <= currentlyInvestigatedQueen % queenProblemProperties.fieldSize && currentFieldToCheck <= currentLegitQueen; currentFieldToCheck += (queenProblemProperties.fieldSize - 1)) //Nach links unten
                {
                    if (currentFieldToCheck === currentLegitQueen) {
                        return true;
                    }
                }

                for (let currentFieldToCheck = currentlyInvestigatedQueen; currentFieldToCheck % queenProblemProperties.fieldSize >= currentlyInvestigatedQueen % queenProblemProperties.fieldSize && currentFieldToCheck <= currentLegitQueen; currentFieldToCheck += (queenProblemProperties.fieldSize + 1)) //Nach rechts unten
                {
                    if (currentFieldToCheck === currentLegitQueen) {
                        return true;
                    }
                }
                return false; //Keine Kollision gefunden
            }
        }

        function checkCollisonRowForLoopfunction(queens) {
            for (let i = 0; i < queens.length; ++i) {
                for (let j = i + 1; j < queens.length; ++j) {
                    if (queens[i] === queens[j]) {
                        return true;
                    }
                }
            }
            return false;
        }

        function checkIfSolutionExcists(foundSolutions, solutionCandidate) {

            for (let solution of foundSolutions) {
                // console.log(`checking ${solutionCandidate} with ${solution}`);


                for (let i = 1; i < 5; i++) {
                    // console.log(`checking ${rotateLeft90(solutionCandidate, i)} with ${solution}`);
                    if (rotateLeft90degree(solutionCandidate, i).equals(solution)) {
                        return true;
                    }
                    if (flipHorizontal(rotateLeft90degree(solutionCandidate, i)).equals(solution)) {
                        return true;
                    }
                    if (flipVertical(rotateLeft90degree(solutionCandidate, i)).equals(solution)) {
                        return true;
                    }
                }

            }

            return false;
        }

        function rotateLeft90degree(solution, flipCounter = 1) {

            let newSolution = [...solution];

            for (let i = 0; i < flipCounter; i++) {
                newSolution.forEach((currentValue, index) => {
                    newSolution[index] = currentValue + queenProblemProperties.fieldSize * queenProblemProperties.fieldSize - queenProblemProperties.fieldSize - (queenProblemProperties.fieldSize + 1) * currentValue + (queenProblemProperties.fieldSize * queenProblemProperties.fieldSize + 1) * Math.floor(currentValue / queenProblemProperties.fieldSize);
                });
            }
            return newSolution.sort((a, b) => { return a - b; });
        }

        function flipHorizontal(solution1d) {
            let newSolution = [...solution1d];
            solution1d.forEach((currentValue, index) => {
                newSolution[index] = queenProblemProperties.fieldSize * (Math.floor(currentValue / queenProblemProperties.fieldSize) + 1) - 1 - currentValue % queenProblemProperties.fieldSize;
            });
            return newSolution.sort((a, b) => { return a - b; });
        }

        function flipVertical(solution1d) {
            let newSolution = [...solution1d];

            solution1d.forEach((currentValue, index) => {
                newSolution[index] = queenProblemProperties.fieldSize * queenProblemProperties.fieldSize + queenProblemProperties.fieldSize - currentValue - 2 * ((queenProblemProperties.fieldSize * queenProblemProperties.fieldSize - (currentValue + 1)) % queenProblemProperties.fieldSize) - 2;
            });
            return newSolution.sort((a, b) => { return a - b; });
        }



    </script>
    <!--JAVASCRIPT CODE ENDE! -->
</body>

</html>