
&lt;pre>
&lt;code>
    

&lt;html>

&lt;head>
    &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    &lt;title>Damenproblem&lt;/title>
    &lt;style type="text/css">
        div {
            outline: 1px solid black;
        }

        .field {
            display: table-cell;
            width: 50px;
            height: 50px;
            text-align: center;
            vertical-align: middle;
            font-size: 18pt;
            background-color: #EFEFEF
        }

        .queen {
            background-color: brown;
            color: white;
        }

        #wrapper {
            display: table;
            table-layout: fixed;
            /*width: 400px;
            height: 400px;*/
            outline: 2px solid black;
        }

        button {
            height: 30px;
            width: 30px;
            font-size: 10pt;
        }

        .button {
            display: inline-block;
            height: 30px;
            width: 30px;
            font-size: 15pt;
            text-align: center;
            vertical-align: middle;
            background-color: EFEFEF;
            border-radius: 10px;
        }

        .button:hover {
            color: white;
            background-color: grey;
            cursor: pointer;
        }

        .unselectable {
            -moz-user-select: -moz-none;
            -khtml-user-select: none;
            -webkit-user-select: none;

            /*
     Introduced in IE 10.
     See http://ie.microsoft.com/testdrive/HTML5/msUserSelect/
   */
            -ms-user-select: none;
            user-select: none;
        }
    &lt;/style>
    &lt;script>
        /* Nice stack overflow code to compare Arrays*/
        //Source: https://stackoverflow.com/questions/7837456/how-to-compare-arrays-in-javascript#14853974

        // Warn if overriding existing method
        if (Array.prototype.equals)
            console.warn("Overriding existing Array.prototype.equals. Possible causes: New API defines the method, there's a framework conflict or you've got double inclusions in your code.");
        // attach the .equals method to Array's prototype to call it on any array
        Array.prototype.equals = function (array) {
            // if the other array is a falsy value, return
            if (!array)
                return false;

            // compare lengths - can save a lot of time 
            if (this.length != array.length)
                return false;

            for (var i = 0, l = this.length; i &lt; l; i++) {
                // Check if we have nested arrays
                if (this[i] instanceof Array && array[i] instanceof Array) {
                    // recurse into the nested arrays
                    if (!this[i].equals(array[i]))
                        return false;
                }
                else if (this[i] != array[i]) {
                    // Warning - two different object instances will never be equal: {x:20} != {x:20}
                    return false;
                }
            }
            return true;
        }
        // Hide method from for-in loops
        Object.defineProperty(Array.prototype, "equals", { enumerable: false });
            /* End of stack overflow code*/
    &lt;/script>
&lt;/head>

&lt;body>

    &lt;br>
    &lt;h1>Das Damenproblem &lt;/h1>
    &lt;br>
    &lt;label for="Spielfeld">Seitenlänge des Spielfeldes&lt;/label>
    &lt;select name="Spielfeld" id="BoardSizeSelect" onchange="updateAll()">
        &lt;option value="1">1&lt;/option>
        &lt;option value="4">4&lt;/option>
        &lt;option value="5">5&lt;/option>
        &lt;option value="6">6&lt;/option>
        &lt;option value="7">7&lt;/option>
        &lt;option selected value="8">8&lt;/option>
        &lt;option value="9">9&lt;/option>
        &lt;option value="10">10&lt;/option>
        &lt;option value="11">11&lt;/option>
    &lt;/select>

    &lt;br>
    &lt;label for="Damen">Lösung auswählen:&lt;/label>
    &lt;select name="Damen" id="DamenSelect" onchange="updateFieldWithOtherSolution();">
        &lt;option>0,12,23,29,34,46,49,59&lt;/option>
    &lt;/select>
    &lt;div class="button unselectable" name="rotieren" title="Spielfeld rotieren"
        onclick="updateFieldWithOtherSolution('rotate')">
        &lt;span> &#11118;&lt;/span>
    &lt;/div>
    &lt;div class="button unselectable" name="horizontal spiegeln" title="Spielfeld horizontal spiegeln"
        onclick="updateFieldWithOtherSolution('flipH')">&lt;span> &#8646; &lt;/span>&lt;/div>
    &lt;div class="button unselectable" name="vertikal spiegeln" title="Spielfeld vertikal spiegeln"
        onclick="updateFieldWithOtherSolution('flipV')">&lt;span> &#8645; &lt;/span>&lt;/div>
    &lt;br>
    &lt;label for="uniqueSoltions">Eindeutige Lösungen: &lt;/label> &lt;span id="uniqueSoltions">0&lt;/span>
    &lt;br>
    &lt;label for="totalSolutions">Lösungen insgesamt: &lt;/label> &lt;span id="totalSolutions">0&lt;/span>
    &lt;br>
    &lt;br>
    &lt;div id="wrapper">


    &lt;/div>
    &lt;!-- JAVASCRIPT CODE HIER! -->
    &lt;script>

        let queenProblemProperties = {
            'fieldSize': 8,
            'iterator': 0,
            'solutionsFound': 0,
            'totalSolutionsFound': 0,
            'allSolutionsArray': [],
            'flipHorizontal': false,
            'flipVertical': false,
            'rotation': 1,
            'currentDisplayedSolution': []
        };

        calculateSolutionsRecursive(queenProblemProperties.allSolutionsArray); //Lösungen berechnen

        drawSolutionAsHtml(queenProblemProperties.currentDisplayedSolution = queenProblemProperties.allSolutionsArray[0]); //Feld zeichnen mit erster Lösung

        fillDropDownWithSolutions(queenProblemProperties.allSolutionsArray); //Drop Down Menü befüllen

        console.log(`Iterationen der Hauptfunktion: ${queenProblemProperties.iterator}`); //Nicht so wichtig


        /************************************************************************************************/
        /* FUNKTIONEN */

        function fillDropDownWithSolutions(allSolutionsArray) //Drop Down Menü befüllen
        {
            let dropDownMenu = document.getElementById('DamenSelect');
            let menuItemStringAsHtmlCode;

            dropDownMenu.innerHTML = "";

            for (let elements of allSolutionsArray) {
                menuItemStringAsHtmlCode = "&lt;option >"
                menuItemStringAsHtmlCode += elements
                menuItemStringAsHtmlCode += "&lt;/option>"
                dropDownMenu.innerHTML += menuItemStringAsHtmlCode;
            }
        }

        function updateFieldWithOtherSolution(state = 'reset') //Funktion wird beim Ändern des Drop Down Menüs aufgerufen
        {

            switch (state) {
                case 'reset':
                    let dropDownMenu = document.getElementById('DamenSelect');
                    let selectedIndexOfDropDownMenu = dropDownMenu.selectedIndex;
                    queenProblemProperties.currentDisplayedSolution = [...queenProblemProperties.allSolutionsArray[selectedIndexOfDropDownMenu]]
                    queenProblemProperties.flipVertical = false;
                    queenProblemProperties.flipHorizontal = false;
                    queenProblemProperties.rotation = 1;
                    break;
                case 'flipV':
                    queenProblemProperties.flipVertical = !queenProblemProperties.flipVertical;
                    queenProblemProperties.currentDisplayedSolution = [...flipVertical(queenProblemProperties.currentDisplayedSolution)];
                    break;
                case 'flipH':
                    queenProblemProperties.flipHorizontal = !queenProblemProperties.flipHorizontal;
                    queenProblemProperties.currentDisplayedSolution = [...flipHorizontal(queenProblemProperties.currentDisplayedSolution)];
                    break;
                case 'rotate':
                    queenProblemProperties.rotation = (queenProblemProperties.rotation === 1) ? 4 : queenProblemProperties.rotation - 1;
                    queenProblemProperties.currentDisplayedSolution = [...rotateLeft90degree(queenProblemProperties.currentDisplayedSolution, 3)];
                    break;
            }
            drawSolutionAsHtml(queenProblemProperties.currentDisplayedSolution);
        }

        function updateAll() {
            queenProblemProperties = {
                'fieldSize': 8,
                'iterator': 0,
                'solutionsFound': 0,
                'totalSolutionsFound': 0,
                'allSolutionsArray': [],
                'flipHorizontal': false,
                'flipVertical': false,
                'rotation': 1,
                'currentDisplayedSolution': []
            };

            queenProblemProperties.fieldSize = Number(document.getElementById('BoardSizeSelect').value);

            calculateSolutionsRecursive(queenProblemProperties.allSolutionsArray);
            console.log(`Iterationen der Hauptfunktion: ${queenProblemProperties.iterator}`); //Nicht so wichtig

            fillDropDownWithSolutions(queenProblemProperties.allSolutionsArray); //Drop Down Menü befüllen 

            drawSolutionAsHtml(queenProblemProperties.currentDisplayedSolution = queenProblemProperties.allSolutionsArray[0]);
        }

        function drawSolutionAsHtml(solution1d) //Spielfeld mit der jeweiligen Lösung in das HTML übertragen
        {
            let solution2d = convertSolutionFrom1dIn2dArrayWithFlags(solution1d)
            let counter = 0;
            let target = document.getElementById("wrapper");
            let rowStringAsHtmlCode; //Speichert HTML code, der dann in die Webseite geschrieben wird
            target.innerHTML = ""; //Wir setzen das Spielfeld zurück

            for (let y_index in solution2d) {
                rowStringAsHtmlCode = "&lt;div>"; //Neue Zeile

                for (let x_index in solution2d[y_index]) //Alle Felder einer Reihe setzen
                {

                    if (solution2d[y_index][x_index]) //Wenn das Feld 'true' ist, steht eine Dame darauf und wir färben es mit der CSS Klasse queen
                    {
                        rowStringAsHtmlCode += "&lt;div class='field queen unselectable'>"
                    }
                    else {
                        rowStringAsHtmlCode += "&lt;div class='field unselectable'>"
                    }
                    rowStringAsHtmlCode += counter;
                    rowStringAsHtmlCode += "&lt;/div>";
                    counter++
                }

                rowStringAsHtmlCode += "&lt;/div>";
                target.innerHTML += rowStringAsHtmlCode; //Zeile Zeichnen
            }

            document.getElementById("uniqueSoltions").innerHTML = queenProblemProperties.solutionsFound;
            document.getElementById("totalSolutions").innerHTML = queenProblemProperties.totalSolutionsFound;

            function convertSolutionFrom1dIn2dArrayWithFlags(solution1d) //Die jeweilige Lösung als einen 2-dimensionalen Boolean Array berechnen
            {
                let solution2d = new Array(queenProblemProperties.fieldSize);

                for (let i = 0; i &lt; queenProblemProperties.fieldSize; ++i) {
                    solution2d[i] = new Array(queenProblemProperties.fieldSize)
                    solution2d[i].fill(false); //Alle Werte standardmäßig auf "false" setzen, auch wird dadurch der Array als Boolean Array initialisiert
                }

                for (let queen of solution1d) {
                    solution2d[Math.floor(queen / queenProblemProperties.fieldSize)][queen % queenProblemProperties.fieldSize] = true; //Position der jeweiligen Dame in den 2-dimensionalen Array eintragen
                }

                return solution2d;
            }
        }

        function calculateSolutionsRecursive(saveSolutionsHere, arrayOfLegitQueens = [], startCheckingCurrentQueenFromHere = 0) //Rekursive Funtion um die Lösungen zu berechnen
        {
            queenProblemProperties.iterator++;

            if (arrayOfLegitQueens[arrayOfLegitQueens.length - 1] > arrayOfLegitQueens.length * queenProblemProperties.fieldSize) // Unnötige Iterationen verwerfen
            {
                return false;
            }

            for (let currentlyInvestigatedQueen = startCheckingCurrentQueenFromHere; currentlyInvestigatedQueen &lt; (queenProblemProperties.fieldSize * queenProblemProperties.fieldSize); currentlyInvestigatedQueen++) //Wir probieren alle Felder aus, ob die Felder zu einer Lösung führen
            {
                if (checkCollisions(arrayOfLegitQueens, currentlyInvestigatedQueen)) //Wenn es eine Kollision gibt, können wir den Rest der Schleife überspringen
                {
                    continue;
                }

                arrayOfLegitQueens.push(currentlyInvestigatedQueen);

                if (arrayOfLegitQueens.length === queenProblemProperties.fieldSize) //Eine Lösung gefunden!
                {
                    queenProblemProperties.totalSolutionsFound++;

                    if (!checkIfSolutionExcists(saveSolutionsHere, arrayOfLegitQueens)) {
                        saveSolutionsHere.push([...arrayOfLegitQueens]); //Lösung speichern
                        queenProblemProperties.solutionsFound++;
                    }
                    arrayOfLegitQueens.pop();
                    continue; //Weitersuchen
                }

                if (calculateSolutionsRecursive(saveSolutionsHere, arrayOfLegitQueens, currentlyInvestigatedQueen + 1)) //die jetzige Position der Dame passt soweit, jetzt können wir eine weitere Dame hinzufügen
                {
                    return true;
                }
                arrayOfLegitQueens.pop();
            }
            return;

            //In Javascript kann man Funktionen in anderen Funktionen deklarieren.
            function checkCollisions(arrayOfLegitQueens, currentlyInvestigatedQueen) //Wir prüfen ob die jetztige Dame mit anderen Damen kolidiert
            {

                if (arrayOfLegitQueens.length === 0) //Wenn es keine weiteren Damen gibt, kann es keine Kollisionen geben 
                {
                    return false;
                }

                for (let currentLegitQueen of arrayOfLegitQueens) //Alle bisher gefundenen Damen überprüfen, ob diese mit der jetzigen Dame kolidieren
                {
                    if (Math.floor(currentLegitQueen / queenProblemProperties.fieldSize) === Math.floor(currentlyInvestigatedQueen / queenProblemProperties.fieldSize)) //Zeile testen
                    {
                        return true;
                    }

                    if (currentLegitQueen % queenProblemProperties.fieldSize === currentlyInvestigatedQueen % queenProblemProperties.fieldSize) //Spalte testen
                    {
                        return true;
                    }

                    if (checkDiagonalCollisions(currentLegitQueen, currentlyInvestigatedQueen)) //Diagonal ist komplizierter, darum wurde das auf eine eigene Funktion ausgelagert
                    {
                        return true;
                    }
                }
                return false;

                //In Javascript kann man Funktionen in anderen Funktionen deklarieren.
                function checkDiagonalCollisions(currentLegitQueen, currentlyInvestigatedQueen) //Diagonal auf Kollisionen überprüfen
                {
                    for (let currentFieldToCheck = currentlyInvestigatedQueen; currentFieldToCheck % queenProblemProperties.fieldSize &lt;= currentlyInvestigatedQueen % queenProblemProperties.fieldSize && currentFieldToCheck >= currentLegitQueen; currentFieldToCheck -= (queenProblemProperties.fieldSize + 1)) //Nach links oben
                    {
                        if (currentFieldToCheck === currentLegitQueen) {
                            return true;
                        }
                    }

                    for (let currentFieldToCheck = currentlyInvestigatedQueen; currentFieldToCheck % queenProblemProperties.fieldSize >= currentlyInvestigatedQueen % queenProblemProperties.fieldSize && currentFieldToCheck >= currentLegitQueen; currentFieldToCheck -= (queenProblemProperties.fieldSize - 1)) //Nach rechts oben
                    {
                        if (currentFieldToCheck === currentLegitQueen) {
                            return true;
                        }
                    }

                    for (let currentFieldToCheck = currentlyInvestigatedQueen; currentFieldToCheck % queenProblemProperties.fieldSize &lt;= currentlyInvestigatedQueen % queenProblemProperties.fieldSize && currentFieldToCheck &lt;= currentLegitQueen; currentFieldToCheck += (queenProblemProperties.fieldSize - 1)) //Nach links unten
                    {
                        if (currentFieldToCheck === currentLegitQueen) {
                            return true;
                        }
                    }

                    for (let currentFieldToCheck = currentlyInvestigatedQueen; currentFieldToCheck % queenProblemProperties.fieldSize >= currentlyInvestigatedQueen % queenProblemProperties.fieldSize && currentFieldToCheck &lt;= currentLegitQueen; currentFieldToCheck += (queenProblemProperties.fieldSize + 1)) //Nach rechts unten
                    {
                        if (currentFieldToCheck === currentLegitQueen) {
                            return true;
                        }
                    }
                    return false; //Keine Kollision gefunden
                }
            }
        }

        function checkIfSolutionExcists(foundSolutions, solutionCandidate) {

            for (let solution of foundSolutions) {
                // console.log(`checking ${solutionCandidate} with ${solution}`);


                for (let i = 1; i &lt; 5; i++) {
                    // console.log(`checking ${rotateLeft90(solutionCandidate, i)} with ${solution}`);
                    if (rotateLeft90degree(solutionCandidate, i).equals(solution)) {
                        return true;
                    }
                    if (flipHorizontal(rotateLeft90degree(solutionCandidate, i)).equals(solution)) {
                        return true;
                    }
                    if (flipVertical(rotateLeft90degree(solutionCandidate, i)).equals(solution)) {
                        return true;
                    }
                }

            }

            return false;
        }

        function rotateLeft90degree(solution, flipCounter = 1) {

            let newSolution = [...solution];

            for (let i = 0; i &lt; flipCounter; i++) {
                newSolution.forEach((currentValue, index) => {
                    newSolution[index] = currentValue + queenProblemProperties.fieldSize * queenProblemProperties.fieldSize - queenProblemProperties.fieldSize - (queenProblemProperties.fieldSize + 1) * currentValue + (queenProblemProperties.fieldSize * queenProblemProperties.fieldSize + 1) * Math.floor(currentValue / queenProblemProperties.fieldSize);
                });
            }
            return newSolution.sort((a, b) => { return a - b; });
        }

        function flipHorizontal(solution1d) {
            let newSolution = [...solution1d];
            solution1d.forEach((currentValue, index) => {
                newSolution[index] = queenProblemProperties.fieldSize * (Math.floor(currentValue / queenProblemProperties.fieldSize) + 1) - 1 - currentValue % queenProblemProperties.fieldSize;
            });
            return newSolution.sort((a, b) => { return a - b; });
        }

        function flipVertical(solution1d) {
            let newSolution = [...solution1d];

            solution1d.forEach((currentValue, index) => {
                newSolution[index] = queenProblemProperties.fieldSize * queenProblemProperties.fieldSize + queenProblemProperties.fieldSize - currentValue - 2 * ((queenProblemProperties.fieldSize * queenProblemProperties.fieldSize - (currentValue + 1)) % queenProblemProperties.fieldSize) - 2;
            });
            return newSolution.sort((a, b) => { return a - b; });
        }
    &lt;/script>
    &lt;!--JAVASCRIPT CODE ENDE! -->
&lt;/body>

&lt;/html>
&lt;/code>
&lt;/pre>
