<html>
<br>    <body>
<br>
<br>&lt;html>
<br>
<br>&lt;head>
<br>    &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<br>    &lt;title>Damenproblem&lt;/title>
<br>    &lt;style type="text/css">
<br>        div {
<br>            outline: 1px solid black;
<br>        }
<br>
<br>        .field {
<br>            display: table-cell;
<br>            width: 50px;
<br>            height: 50px;
<br>            text-align: center;
<br>            vertical-align: middle;
<br>            font-size: 18pt;
<br>            background-color: #EFEFEF
<br>        }
<br>
<br>        .queen {
<br>            background-color: brown;
<br>            color: white;
<br>        }
<br>
<br>        #wrapper {
<br>            display: table;
<br>            table-layout: fixed;
<br>            /*width: 400px;
<br>            height: 400px;*/
<br>            outline: 2px solid black;
<br>        }
<br>
<br>        button {
<br>            height: 30px;
<br>            width: 30px;
<br>            font-size: 10pt;
<br>        }
<br>
<br>        .button {
<br>            display: inline-block;
<br>            height: 30px;
<br>            width: 30px;
<br>            font-size: 15pt;
<br>            text-align: center;
<br>            vertical-align: middle;
<br>            background-color: EFEFEF;
<br>            border-radius: 10px;
<br>        }
<br>
<br>        .button:hover {
<br>            color: white;
<br>            background-color: grey;
<br>            cursor: pointer;
<br>        }
<br>
<br>        .unselectable {
<br>            -moz-user-select: -moz-none;
<br>            -khtml-user-select: none;
<br>            -webkit-user-select: none;
<br>
<br>            /*
<br>     Introduced in IE 10.
<br>     See http://ie.microsoft.com/testdrive/HTML5/msUserSelect/
<br>   */
<br>            -ms-user-select: none;
<br>            user-select: none;
<br>        }
<br>    &lt;/style>
<br>    &lt;script>
<br>        /* Nice stack overflow code to compare Arrays*/
<br>        //Source: https://stackoverflow.com/questions/7837456/how-to-compare-arrays-in-javascript#14853974
<br>
<br>        // Warn if overriding existing method
<br>        if (Array.prototype.equals)
<br>            console.warn("Overriding existing Array.prototype.equals. Possible causes: New API defines the method, there's a framework conflict or you've got double inclusions in your code.");
<br>        // attach the .equals method to Array's prototype to call it on any array
<br>        Array.prototype.equals = function (array) {
<br>            // if the other array is a falsy value, return
<br>            if (!array)
<br>                return false;
<br>
<br>            // compare lengths - can save a lot of time 
<br>            if (this.length != array.length)
<br>                return false;
<br>
<br>            for (var i = 0, l = this.length; i &lt; l; i++) {
<br>                // Check if we have nested arrays
<br>                if (this[i] instanceof Array && array[i] instanceof Array) {
<br>                    // recurse into the nested arrays
<br>                    if (!this[i].equals(array[i]))
<br>                        return false;
<br>                }
<br>                else if (this[i] != array[i]) {
<br>                    // Warning - two different object instances will never be equal: {x:20} != {x:20}
<br>                    return false;
<br>                }
<br>            }
<br>            return true;
<br>        }
<br>        // Hide method from for-in loops
<br>        Object.defineProperty(Array.prototype, "equals", { enumerable: false });
<br>            /* End of stack overflow code*/
<br>    &lt;/script>
<br>&lt;/head>
<br>
<br>&lt;body>
<br>
<br>    &lt;br>
<br>    &lt;h1>Das Damenproblem &lt;/h1>
<br>    &lt;br>
<br>    &lt;label for="Spielfeld">Seitenlänge des Spielfeldes&lt;/label>
<br>    &lt;select name="Spielfeld" id="BoardSizeSelect" onchange="updateAll()">
<br>        &lt;option value="1">1&lt;/option>
<br>        &lt;option value="4">4&lt;/option>
<br>        &lt;option value="5">5&lt;/option>
<br>        &lt;option value="6">6&lt;/option>
<br>        &lt;option value="7">7&lt;/option>
<br>        &lt;option selected value="8">8&lt;/option>
<br>        &lt;option value="9">9&lt;/option>
<br>        &lt;option value="10">10&lt;/option>
<br>        &lt;option value="11">11&lt;/option>
<br>    &lt;/select>
<br>
<br>    &lt;br>
<br>    &lt;label for="Damen">Lösung auswählen:&lt;/label>
<br>    &lt;select name="Damen" id="DamenSelect" onchange="updateFieldWithOtherSolution();">
<br>        &lt;option>0,12,23,29,34,46,49,59&lt;/option>
<br>    &lt;/select>
<br>    &lt;div class="button unselectable" name="rotieren" title="Spielfeld rotieren"
<br>        onclick="updateFieldWithOtherSolution('rotate')">
<br>        &lt;span> &#11118;&lt;/span>
<br>    &lt;/div>
<br>    &lt;div class="button unselectable" name="horizontal spiegeln" title="Spielfeld horizontal spiegeln"
<br>        onclick="updateFieldWithOtherSolution('flipH')">&lt;span> &#8646; &lt;/span>&lt;/div>
<br>    &lt;div class="button unselectable" name="vertikal spiegeln" title="Spielfeld vertikal spiegeln"
<br>        onclick="updateFieldWithOtherSolution('flipV')">&lt;span> &#8645; &lt;/span>&lt;/div>
<br>    &lt;br>
<br>    &lt;label for="uniqueSoltions">Eindeutige Lösungen: &lt;/label> &lt;span id="uniqueSoltions">0&lt;/span>
<br>    &lt;br>
<br>    &lt;label for="totalSolutions">Lösungen insgesamt: &lt;/label> &lt;span id="totalSolutions">0&lt;/span>
<br>    &lt;br>
<br>    &lt;br>
<br>    &lt;div id="wrapper">
<br>
<br>
<br>    &lt;/div>
<br>    &lt;!-- JAVASCRIPT CODE HIER! -->
<br>    &lt;script>
<br>
<br>        let queenProblemProperties = {
<br>            'fieldSize': 8,
<br>            'iterator': 0,
<br>            'solutionsFound': 0,
<br>            'totalSolutionsFound': 0,
<br>            'allSolutionsArray': [],
<br>            'flipHorizontal': false,
<br>            'flipVertical': false,
<br>            'rotation': 1,
<br>            'currentDisplayedSolution': []
<br>        };
<br>
<br>        calculateSolutionsRecursive(queenProblemProperties.allSolutionsArray); //Lösungen berechnen
<br>
<br>        drawSolutionAsHtml(queenProblemProperties.currentDisplayedSolution = queenProblemProperties.allSolutionsArray[0]); //Feld zeichnen mit erster Lösung
<br>
<br>        fillDropDownWithSolutions(queenProblemProperties.allSolutionsArray); //Drop Down Menü befüllen
<br>
<br>        console.log(`Iterationen der Hauptfunktion: ${queenProblemProperties.iterator}`); //Nicht so wichtig
<br>
<br>
<br>        /************************************************************************************************/
<br>        /* FUNKTIONEN */
<br>
<br>        function fillDropDownWithSolutions(allSolutionsArray) //Drop Down Menü befüllen
<br>        {
<br>            let dropDownMenu = document.getElementById('DamenSelect');
<br>            let menuItemStringAsHtmlCode;
<br>
<br>            dropDownMenu.innerHTML = "";
<br>
<br>            for (let elements of allSolutionsArray) {
<br>                menuItemStringAsHtmlCode = "&lt;option >"
<br>                menuItemStringAsHtmlCode += elements
<br>                menuItemStringAsHtmlCode += "&lt;/option>"
<br>                dropDownMenu.innerHTML += menuItemStringAsHtmlCode;
<br>            }
<br>        }
<br>
<br>        function updateFieldWithOtherSolution(state = 'reset') //Funktion wird beim Ändern des Drop Down Menüs aufgerufen
<br>        {
<br>
<br>            switch (state) {
<br>                case 'reset':
<br>                    let dropDownMenu = document.getElementById('DamenSelect');
<br>                    let selectedIndexOfDropDownMenu = dropDownMenu.selectedIndex;
<br>                    queenProblemProperties.currentDisplayedSolution = [...queenProblemProperties.allSolutionsArray[selectedIndexOfDropDownMenu]]
<br>                    queenProblemProperties.flipVertical = false;
<br>                    queenProblemProperties.flipHorizontal = false;
<br>                    queenProblemProperties.rotation = 1;
<br>                    break;
<br>                case 'flipV':
<br>                    queenProblemProperties.flipVertical = !queenProblemProperties.flipVertical;
<br>                    queenProblemProperties.currentDisplayedSolution = [...flipVertical(queenProblemProperties.currentDisplayedSolution)];
<br>                    break;
<br>                case 'flipH':
<br>                    queenProblemProperties.flipHorizontal = !queenProblemProperties.flipHorizontal;
<br>                    queenProblemProperties.currentDisplayedSolution = [...flipHorizontal(queenProblemProperties.currentDisplayedSolution)];
<br>                    break;
<br>                case 'rotate':
<br>                    queenProblemProperties.rotation = (queenProblemProperties.rotation === 1) ? 4 : queenProblemProperties.rotation - 1;
<br>                    queenProblemProperties.currentDisplayedSolution = [...rotateLeft90degree(queenProblemProperties.currentDisplayedSolution, 3)];
<br>                    break;
<br>            }
<br>            drawSolutionAsHtml(queenProblemProperties.currentDisplayedSolution);
<br>        }
<br>
<br>        function updateAll() {
<br>            queenProblemProperties = {
<br>                'fieldSize': 8,
<br>                'iterator': 0,
<br>                'solutionsFound': 0,
<br>                'totalSolutionsFound': 0,
<br>                'allSolutionsArray': [],
<br>                'flipHorizontal': false,
<br>                'flipVertical': false,
<br>                'rotation': 1,
<br>                'currentDisplayedSolution': []
<br>            };
<br>
<br>            queenProblemProperties.fieldSize = Number(document.getElementById('BoardSizeSelect').value);
<br>
<br>            calculateSolutionsRecursive(queenProblemProperties.allSolutionsArray);
<br>            console.log(`Iterationen der Hauptfunktion: ${queenProblemProperties.iterator}`); //Nicht so wichtig
<br>
<br>            fillDropDownWithSolutions(queenProblemProperties.allSolutionsArray); //Drop Down Menü befüllen 
<br>
<br>            drawSolutionAsHtml(queenProblemProperties.currentDisplayedSolution = queenProblemProperties.allSolutionsArray[0]);
<br>        }
<br>
<br>        function drawSolutionAsHtml(solution1d) //Spielfeld mit der jeweiligen Lösung in das HTML übertragen
<br>        {
<br>            let solution2d = convertSolutionFrom1dIn2dArrayWithFlags(solution1d)
<br>            let counter = 0;
<br>            let target = document.getElementById("wrapper");
<br>            let rowStringAsHtmlCode; //Speichert HTML code, der dann in die Webseite geschrieben wird
<br>            target.innerHTML = ""; //Wir setzen das Spielfeld zurück
<br>
<br>            for (let y_index in solution2d) {
<br>                rowStringAsHtmlCode = "&lt;div>"; //Neue Zeile
<br>
<br>                for (let x_index in solution2d[y_index]) //Alle Felder einer Reihe setzen
<br>                {
<br>
<br>                    if (solution2d[y_index][x_index]) //Wenn das Feld 'true' ist, steht eine Dame darauf und wir färben es mit der CSS Klasse queen
<br>                    {
<br>                        rowStringAsHtmlCode += "&lt;div class='field queen unselectable'>"
<br>                    }
<br>                    else {
<br>                        rowStringAsHtmlCode += "&lt;div class='field unselectable'>"
<br>                    }
<br>                    rowStringAsHtmlCode += counter;
<br>                    rowStringAsHtmlCode += "&lt;/div>";
<br>                    counter++
<br>                }
<br>
<br>                rowStringAsHtmlCode += "&lt;/div>";
<br>                target.innerHTML += rowStringAsHtmlCode; //Zeile Zeichnen
<br>            }
<br>
<br>            document.getElementById("uniqueSoltions").innerHTML = queenProblemProperties.solutionsFound;
<br>            document.getElementById("totalSolutions").innerHTML = queenProblemProperties.totalSolutionsFound;
<br>
<br>            function convertSolutionFrom1dIn2dArrayWithFlags(solution1d) //Die jeweilige Lösung als einen 2-dimensionalen Boolean Array berechnen
<br>            {
<br>                let solution2d = new Array(queenProblemProperties.fieldSize);
<br>
<br>                for (let i = 0; i &lt; queenProblemProperties.fieldSize; ++i) {
<br>                    solution2d[i] = new Array(queenProblemProperties.fieldSize)
<br>                    solution2d[i].fill(false); //Alle Werte standardmäßig auf "false" setzen, auch wird dadurch der Array als Boolean Array initialisiert
<br>                }
<br>
<br>                for (let queen of solution1d) {
<br>                    solution2d[Math.floor(queen / queenProblemProperties.fieldSize)][queen % queenProblemProperties.fieldSize] = true; //Position der jeweiligen Dame in den 2-dimensionalen Array eintragen
<br>                }
<br>
<br>                return solution2d;
<br>            }
<br>        }
<br>
<br>        function calculateSolutionsRecursive(saveSolutionsHere, arrayOfLegitQueens = [], startCheckingCurrentQueenFromHere = 0) //Rekursive Funtion um die Lösungen zu berechnen
<br>        {
<br>            queenProblemProperties.iterator++;
<br>
<br>            if (arrayOfLegitQueens[arrayOfLegitQueens.length - 1] > arrayOfLegitQueens.length * queenProblemProperties.fieldSize) // Unnötige Iterationen verwerfen
<br>            {
<br>                return false;
<br>            }
<br>
<br>            for (let currentlyInvestigatedQueen = startCheckingCurrentQueenFromHere; currentlyInvestigatedQueen &lt; (queenProblemProperties.fieldSize * queenProblemProperties.fieldSize); currentlyInvestigatedQueen++) //Wir probieren alle Felder aus, ob die Felder zu einer Lösung führen
<br>            {
<br>                if (checkCollisions(arrayOfLegitQueens, currentlyInvestigatedQueen)) //Wenn es eine Kollision gibt, können wir den Rest der Schleife überspringen
<br>                {
<br>                    continue;
<br>                }
<br>
<br>                arrayOfLegitQueens.push(currentlyInvestigatedQueen);
<br>
<br>                if (arrayOfLegitQueens.length === queenProblemProperties.fieldSize) //Eine Lösung gefunden!
<br>                {
<br>                    queenProblemProperties.totalSolutionsFound++;
<br>
<br>                    if (!checkIfSolutionExcists(saveSolutionsHere, arrayOfLegitQueens)) {
<br>                        saveSolutionsHere.push([...arrayOfLegitQueens]); //Lösung speichern
<br>                        queenProblemProperties.solutionsFound++;
<br>                    }
<br>                    arrayOfLegitQueens.pop();
<br>                    continue; //Weitersuchen
<br>                }
<br>
<br>                if (calculateSolutionsRecursive(saveSolutionsHere, arrayOfLegitQueens, currentlyInvestigatedQueen + 1)) //die jetzige Position der Dame passt soweit, jetzt können wir eine weitere Dame hinzufügen
<br>                {
<br>                    return true;
<br>                }
<br>                arrayOfLegitQueens.pop();
<br>            }
<br>            return;
<br>
<br>            //In Javascript kann man Funktionen in anderen Funktionen deklarieren.
<br>            function checkCollisions(arrayOfLegitQueens, currentlyInvestigatedQueen) //Wir prüfen ob die jetztige Dame mit anderen Damen kolidiert
<br>            {
<br>
<br>                if (arrayOfLegitQueens.length === 0) //Wenn es keine weiteren Damen gibt, kann es keine Kollisionen geben 
<br>                {
<br>                    return false;
<br>                }
<br>
<br>                for (let currentLegitQueen of arrayOfLegitQueens) //Alle bisher gefundenen Damen überprüfen, ob diese mit der jetzigen Dame kolidieren
<br>                {
<br>                    if (Math.floor(currentLegitQueen / queenProblemProperties.fieldSize) === Math.floor(currentlyInvestigatedQueen / queenProblemProperties.fieldSize)) //Zeile testen
<br>                    {
<br>                        return true;
<br>                    }
<br>
<br>                    if (currentLegitQueen % queenProblemProperties.fieldSize === currentlyInvestigatedQueen % queenProblemProperties.fieldSize) //Spalte testen
<br>                    {
<br>                        return true;
<br>                    }
<br>
<br>                    if (checkDiagonalCollisions(currentLegitQueen, currentlyInvestigatedQueen)) //Diagonal ist komplizierter, darum wurde das auf eine eigene Funktion ausgelagert
<br>                    {
<br>                        return true;
<br>                    }
<br>                }
<br>                return false;
<br>
<br>                //In Javascript kann man Funktionen in anderen Funktionen deklarieren.
<br>                function checkDiagonalCollisions(currentLegitQueen, currentlyInvestigatedQueen) //Diagonal auf Kollisionen überprüfen
<br>                {
<br>                    for (let currentFieldToCheck = currentlyInvestigatedQueen; currentFieldToCheck % queenProblemProperties.fieldSize &lt;= currentlyInvestigatedQueen % queenProblemProperties.fieldSize && currentFieldToCheck >= currentLegitQueen; currentFieldToCheck -= (queenProblemProperties.fieldSize + 1)) //Nach links oben
<br>                    {
<br>                        if (currentFieldToCheck === currentLegitQueen) {
<br>                            return true;
<br>                        }
<br>                    }
<br>
<br>                    for (let currentFieldToCheck = currentlyInvestigatedQueen; currentFieldToCheck % queenProblemProperties.fieldSize >= currentlyInvestigatedQueen % queenProblemProperties.fieldSize && currentFieldToCheck >= currentLegitQueen; currentFieldToCheck -= (queenProblemProperties.fieldSize - 1)) //Nach rechts oben
<br>                    {
<br>                        if (currentFieldToCheck === currentLegitQueen) {
<br>                            return true;
<br>                        }
<br>                    }
<br>
<br>                    for (let currentFieldToCheck = currentlyInvestigatedQueen; currentFieldToCheck % queenProblemProperties.fieldSize &lt;= currentlyInvestigatedQueen % queenProblemProperties.fieldSize && currentFieldToCheck &lt;= currentLegitQueen; currentFieldToCheck += (queenProblemProperties.fieldSize - 1)) //Nach links unten
<br>                    {
<br>                        if (currentFieldToCheck === currentLegitQueen) {
<br>                            return true;
<br>                        }
<br>                    }
<br>
<br>                    for (let currentFieldToCheck = currentlyInvestigatedQueen; currentFieldToCheck % queenProblemProperties.fieldSize >= currentlyInvestigatedQueen % queenProblemProperties.fieldSize && currentFieldToCheck &lt;= currentLegitQueen; currentFieldToCheck += (queenProblemProperties.fieldSize + 1)) //Nach rechts unten
<br>                    {
<br>                        if (currentFieldToCheck === currentLegitQueen) {
<br>                            return true;
<br>                        }
<br>                    }
<br>                    return false; //Keine Kollision gefunden
<br>                }
<br>            }
<br>        }
<br>
<br>        function checkIfSolutionExcists(foundSolutions, solutionCandidate) {
<br>
<br>            for (let solution of foundSolutions) {
<br>                // console.log(`checking ${solutionCandidate} with ${solution}`);
<br>
<br>
<br>                for (let i = 1; i &lt; 5; i++) {
<br>                    // console.log(`checking ${rotateLeft90(solutionCandidate, i)} with ${solution}`);
<br>                    if (rotateLeft90degree(solutionCandidate, i).equals(solution)) {
<br>                        return true;
<br>                    }
<br>                    if (flipHorizontal(rotateLeft90degree(solutionCandidate, i)).equals(solution)) {
<br>                        return true;
<br>                    }
<br>                    if (flipVertical(rotateLeft90degree(solutionCandidate, i)).equals(solution)) {
<br>                        return true;
<br>                    }
<br>                }
<br>
<br>            }
<br>
<br>            return false;
<br>        }
<br>
<br>        function rotateLeft90degree(solution, flipCounter = 1) {
<br>
<br>            let newSolution = [...solution];
<br>
<br>            for (let i = 0; i &lt; flipCounter; i++) {
<br>                newSolution.forEach((currentValue, index) => {
<br>                    newSolution[index] = currentValue + queenProblemProperties.fieldSize * queenProblemProperties.fieldSize - queenProblemProperties.fieldSize - (queenProblemProperties.fieldSize + 1) * currentValue + (queenProblemProperties.fieldSize * queenProblemProperties.fieldSize + 1) * Math.floor(currentValue / queenProblemProperties.fieldSize);
<br>                });
<br>            }
<br>            return newSolution.sort((a, b) => { return a - b; });
<br>        }
<br>
<br>        function flipHorizontal(solution1d) {
<br>            let newSolution = [...solution1d];
<br>            solution1d.forEach((currentValue, index) => {
<br>                newSolution[index] = queenProblemProperties.fieldSize * (Math.floor(currentValue / queenProblemProperties.fieldSize) + 1) - 1 - currentValue % queenProblemProperties.fieldSize;
<br>            });
<br>            return newSolution.sort((a, b) => { return a - b; });
<br>        }
<br>
<br>        function flipVertical(solution1d) {
<br>            let newSolution = [...solution1d];
<br>
<br>            solution1d.forEach((currentValue, index) => {
<br>                newSolution[index] = queenProblemProperties.fieldSize * queenProblemProperties.fieldSize + queenProblemProperties.fieldSize - currentValue - 2 * ((queenProblemProperties.fieldSize * queenProblemProperties.fieldSize - (currentValue + 1)) % queenProblemProperties.fieldSize) - 2;
<br>            });
<br>            return newSolution.sort((a, b) => { return a - b; });
<br>        }
<br>    &lt;/script>
<br>    &lt;!--JAVASCRIPT CODE ENDE! -->
<br>&lt;/body>
<br>
<br>&lt;/html>
<br>    </body>
<br>    </html>